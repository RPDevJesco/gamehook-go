<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced GameHook Admin Panel</title>
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --bg-card: #2d2d30;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --text-muted: #888888;
      --accent-primary: #4CAF50;
      --accent-secondary: #2196F3;
      --accent-warning: #FF9800;
      --accent-error: #f44336;
      --accent-purple: #9C27B0;
      --border-color: #404040;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      overflow-x: hidden;
    }

    .header {
      background: var(--bg-secondary);
      padding: 1rem 2rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      background: var(--gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 1.8rem;
      font-weight: 700;
    }

    .status-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-error);
      transition: all 0.3s ease;
      animation: pulse-error 2s infinite;
    }

    .status-indicator.connected {
      background: var(--accent-primary);
      animation: pulse-success 2s infinite;
    }

    .debug-panel {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .debug-header {
      display: flex;
      justify-content: between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .debug-toggle {
      background: var(--accent-secondary);
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .debug-log {
      background: var(--bg-primary);
      padding: 0.5rem;
      border-radius: 4px;
      white-space: pre-wrap;
      word-break: break-all;
    }

    @keyframes pulse-error {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @keyframes pulse-success {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .container {
      display: grid;
      grid-template-columns: 280px 1fr;
      height: calc(100vh - 80px);
    }

    .sidebar {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      padding: 1.5rem;
      overflow-y: auto;
      box-shadow: var(--shadow);
    }

    .sidebar h2 {
      color: var(--accent-secondary);
      font-size: 1.1rem;
      margin-bottom: 1rem;
      font-weight: 600;
    }

    .mapper-list {
      list-style: none;
    }

    .mapper-item {
      padding: 0.8rem;
      margin-bottom: 0.5rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      position: relative;
      overflow: hidden;
    }

    .mapper-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .mapper-item:hover::before {
      opacity: 0.1;
    }

    .mapper-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }

    .mapper-item.active {
      border-color: var(--accent-primary);
      background: var(--bg-card);
    }

    .mapper-item.active::before {
      opacity: 0.05;
    }

    .mapper-name {
      font-weight: 600;
      color: var(--text-primary);
      position: relative;
      z-index: 1;
    }

    .mapper-platform {
      font-size: 0.85rem;
      color: var(--text-muted);
      position: relative;
      z-index: 1;
    }

    .main-content {
      padding: 2rem;
      overflow-y: auto;
      background: var(--bg-primary);
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 2rem;
      background: var(--bg-secondary);
      border-radius: 8px 8px 0 0;
      padding: 0 1rem;
    }

    .tab {
      padding: 1rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
      font-weight: 500;
      position: relative;
    }

    .tab:hover {
      background: var(--bg-tertiary);
      color: var(--accent-primary);
    }

    .tab.active {
      border-bottom-color: var(--accent-primary);
      color: var(--accent-primary);
      background: var(--bg-card);
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .section {
      margin-bottom: 2rem;
    }

    .section h2 {
      color: var(--accent-secondary);
      font-size: 1.4rem;
      margin-bottom: 1rem;
      font-weight: 600;
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow);
      transition: all 0.2s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .card h3 {
      margin: 0 0 1rem 0;
      color: var(--text-primary);
      font-weight: 600;
    }

    .property-groups {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 1.5rem;
    }

    .property-group {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow);
      transition: all 0.2s ease;
    }

    .property-group:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .group-header {
      padding: 1rem 1.5rem;
      background: var(--gradient);
      color: white;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
    }

    .group-icon {
      font-size: 1.2rem;
    }

    .group-title {
      font-weight: 600;
      flex: 1;
    }

    .group-toggle {
      font-size: 0.8rem;
      transition: transform 0.2s ease;
    }

    .group-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .group-content {
      padding: 1rem;
      max-height: 500px;
      overflow-y: auto;
    }

    .group-content.collapsed {
      display: none;
    }

    .property-item {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border-left: 4px solid var(--accent-primary);
      transition: all 0.2s ease;
    }

    .property-item:hover {
      background: var(--bg-secondary);
      transform: translateX(4px);
    }

    .property-item.frozen {
      border-left-color: var(--accent-warning);
      background: rgba(255, 152, 0, 0.1);
    }

    .property-item.read-only {
      border-left-color: var(--text-muted);
    }

    .property-item.computed {
      border-left-color: var(--accent-purple);
      background: rgba(156, 39, 176, 0.1);
    }

    .property-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .property-name {
      font-weight: 600;
      color: var(--text-primary);
    }

    .property-description {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .property-meta {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .property-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent-primary);
      font-family: 'JetBrains Mono', monospace;
      padding: 0.25rem 0.5rem;
      background: var(--bg-primary);
      border-radius: 4px;
      min-width: 80px;
      text-align: center;
    }

    .property-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .btn-primary {
      background: var(--accent-primary);
      color: white;
    }

    .btn-secondary {
      background: var(--accent-secondary);
      color: white;
    }

    .btn-warning {
      background: var(--accent-warning);
      color: white;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .freeze-toggle {
      background: var(--accent-warning);
      color: white;
    }

    .freeze-toggle.frozen {
      background: var(--accent-error);
    }

    .messages {
      position: fixed;
      top: 100px;
      right: 20px;
      z-index: 1000;
      max-width: 400px;
    }

    .message {
      padding: 1rem;
      margin-bottom: 0.5rem;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: var(--shadow);
      animation: slideIn 0.3s ease;
    }

    .message.success {
      background: var(--accent-primary);
    }

    .message.error {
      background: var(--accent-error);
    }

    .message.warning {
      background: var(--accent-warning);
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: var(--bg-card);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow);
      transition: all 0.2s ease;
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-primary);
      margin-bottom: 0.5rem;
    }

    .stat-label {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .loading {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
      font-style: italic;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s infinite;
    }

    @keyframes dots {
      0%, 20% { color: transparent; }
      40% { color: var(--text-muted); }
      100% { color: transparent; }
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 3rem;
      font-style: italic;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 1024px) {
      .container {
        grid-template-columns: 1fr;
      }

      .sidebar {
        display: none;
      }

      .property-groups {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
      }

      .main-content {
        padding: 1rem;
      }

      .tabs {
        flex-wrap: wrap;
      }

      .property-item {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
<div class="header">
  <h1>üéÆ Enhanced GameHook</h1>
  <div class="status-section">
    <div class="status">
      <div class="status-indicator" id="statusIndicator"></div>
      <span id="statusText">Connecting...</span>
    </div>
    <div class="status">
      <span id="updateRate">60 FPS</span>
    </div>
  </div>
</div>

<div class="messages" id="messages"></div>

<div class="container">
  <div class="sidebar">
    <div class="section">
      <h2>Available Mappers</h2>
      <ul class="mapper-list" id="mapperList">
        <li class="loading">Loading mappers...</li>
      </ul>
    </div>
  </div>

  <div class="main-content">
    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel" style="display: none;">
      <div class="debug-header">
        <h4>üîç Debug Log</h4>
        <button class="debug-toggle" onclick="toggleDebug()">Hide</button>
      </div>
      <div class="debug-log" id="debugLog">Debug information will appear here...</div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="overview">Overview</div>
      <div class="tab" data-tab="properties">Properties</div>
      <div class="tab" data-tab="monitoring">Monitoring</div>
      <div class="tab" data-tab="debug">Debug</div>
    </div>

    <!-- Overview Tab -->
    <div class="tab-content active" id="overview">
      <div class="section">
        <h2>Mapper Information</h2>
        <div class="card" id="mapperInfo">
          <div class="loading">No mapper loaded</div>
        </div>
      </div>

      <div class="section">
        <h2>Statistics</h2>
        <div class="stats-grid" id="statsGrid">
          <div class="stat-card">
            <div class="stat-value" id="statProperties">0</div>
            <div class="stat-label">Properties</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statFrozen">0</div>
            <div class="stat-label">Frozen</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statGroups">0</div>
            <div class="stat-label">Groups</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statComputed">0</div>
            <div class="stat-label">Computed</div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>Quick Actions</h2>
        <div class="card">
          <button class="btn btn-primary" onclick="refreshMappers()">
            üîÑ Refresh Mappers
          </button>
          <button class="btn btn-secondary" onclick="loadSelectedMapper()">
            üìã Load Selected
          </button>
          <button class="btn btn-warning" onclick="toggleDebug()">
            üîç Toggle Debug
          </button>
          <button class="btn btn-secondary" onclick="testPropertyAccess()">
            üß™ Test Property Access
          </button>
        </div>
      </div>
    </div>

    <!-- Properties Tab -->
    <div class="tab-content" id="properties">
      <div class="section">
        <h2>Property Groups</h2>
        <div class="property-groups" id="propertyGroups">
          <div class="loading">Load a mapper to see properties</div>
        </div>
      </div>
    </div>

    <!-- Monitoring Tab -->
    <div class="tab-content" id="monitoring">
      <div class="section">
        <h2>Real-time Property Monitoring</h2>
        <div class="card">
          <h3>Monitor Settings</h3>
          <label>
            Update Rate:
            <select id="updateRateSelect" onchange="changeUpdateRate()">
              <option value="16">60 FPS (16ms)</option>
              <option value="33">30 FPS (33ms)</option>
              <option value="100">10 FPS (100ms)</option>
              <option value="1000">1 FPS (1000ms)</option>
            </select>
          </label>
        </div>
        <div class="card">
          <h3>Property Changes</h3>
          <div id="propertyChanges">
            <div class="empty-state">No property changes detected</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Debug Tab -->
    <div class="tab-content" id="debug">
      <div class="section">
        <h2>Debug Information</h2>
        <div class="card">
          <h3>API Endpoints</h3>
          <button class="btn btn-secondary" onclick="testApiEndpoint('/api/mappers')">Test /api/mappers</button>
          <button class="btn btn-secondary" onclick="testApiEndpoint('/api/mapper')">Test /api/mapper</button>
          <button class="btn btn-secondary" onclick="testApiEndpoint('/api/properties')">Test /api/properties</button>
          <button class="btn btn-secondary" onclick="testApiEndpoint('/api/mapper/glossary')">Test /api/mapper/glossary</button>
        </div>

        <div class="card">
          <h3>System Information</h3>
          <div id="systemInfo">
            <div class="loading">Loading system information...</div>
          </div>
        </div>

        <div class="card">
          <h3>Raw Debug Log</h3>
          <div class="debug-log" id="fullDebugLog" style="max-height: 400px; overflow-y: auto;">
            Debug information will appear here...
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  class EnhancedGameHookAdmin {
    constructor() {
      this.baseUrl = 'http://localhost:8080';
      this.ws = null;
      this.connected = false;
      this.currentMapper = null;
      this.selectedMapperId = null;
      this.properties = new Map();
      this.propertyGroups = new Map();
      this.updateRate = 16;
      this.changeHistory = [];
      this.debugMode = false;
      this.debugLog = [];

      this.init();
    }

    init() {
      this.setupEventListeners();
      this.connect();
      this.refreshMappers();
      this.startPolling();
    }

    setupEventListeners() {
      // Tab switching
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          this.switchTab(tabId);
        });
      });
    }

    switchTab(tabId) {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');

      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabId).classList.add('active');
    }

    logDebug(message, data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ${message}`;

      this.debugLog.push({ timestamp, message, data });

      // Keep only last 100 entries
      if (this.debugLog.length > 100) {
        this.debugLog.shift();
      }

      // Update debug displays
      this.updateDebugDisplays(logEntry, data);

      console.log(message, data || '');
    }

    updateDebugDisplays(logEntry, data = null) {
      const debugLogElement = document.getElementById('debugLog');
      const fullDebugLogElement = document.getElementById('fullDebugLog');

      const entry = data ? `${logEntry}\n${JSON.stringify(data, null, 2)}` : logEntry;

      if (debugLogElement) {
        debugLogElement.textContent = entry + '\n' + debugLogElement.textContent;
      }

      if (fullDebugLogElement) {
        fullDebugLogElement.textContent = entry + '\n' + fullDebugLogElement.textContent;
      }
    }

    async connect() {
      try {
        this.logDebug('üîå Attempting HTTP connection...');
        const response = await fetch(`${this.baseUrl}/api/mappers`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

        this.logDebug('‚úÖ HTTP connection successful');

        // Setup WebSocket
        this.logDebug('üîå Setting up WebSocket connection...');
        this.ws = new WebSocket(`ws://localhost:8080/api/stream`);

        this.ws.onopen = () => {
          this.connected = true;
          this.updateStatus();
          this.logDebug('‚úÖ WebSocket connected');
          this.refreshCurrentMapper();
        };

        this.ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          this.logDebug('üì® WebSocket message received', data);
          this.handleWebSocketMessage(data);
        };

        this.ws.onclose = () => {
          this.connected = false;
          this.updateStatus();
          this.logDebug('‚ùå WebSocket disconnected, reconnecting in 3s...');
          setTimeout(() => this.connect(), 3000);
        };

        this.ws.onerror = (error) => {
          this.logDebug('‚ùå WebSocket error', error);
        };

      } catch (error) {
        this.connected = false;
        this.updateStatus();
        this.logDebug('‚ùå Connection failed', error);
        setTimeout(() => this.connect(), 3000);
      }
    }

    startPolling() {
      // Poll property values every 2 seconds
      setInterval(() => {
        if (this.currentMapper) {
          this.pollPropertyValues();
        }
      }, 2000);
    }

    async pollPropertyValues() {
      try {
        const response = await fetch(`${this.baseUrl}/api/properties`);
        if (response.ok) {
          const data = await response.json();
          this.logDebug(`üîÑ Polled ${data.properties?.length || 0} properties`);
          this.updatePropertyValues(data.properties);
        }
      } catch (error) {
        this.logDebug('‚ùå Property polling failed', error);
      }
    }

    updatePropertyValues(properties) {
      if (!properties) return;

      properties.forEach(prop => {
        const valueElement = document.getElementById(`value-${prop.name}`);
        if (valueElement) {
          valueElement.textContent = this.formatValue(prop.value);
          valueElement.style.animation = 'none';
          valueElement.offsetHeight; // Force reflow
          valueElement.style.animation = 'fadeIn 0.3s ease';
        }
      });
    }

    updateStatus() {
      const indicator = document.getElementById('statusIndicator');
      const text = document.getElementById('statusText');

      if (this.connected) {
        indicator.classList.add('connected');
        text.textContent = 'Connected';
      } else {
        indicator.classList.remove('connected');
        text.textContent = 'Disconnected';
      }
    }

    handleWebSocketMessage(data) {
      switch (data.type) {
        case 'connected':
          this.logDebug('üì° Enhanced WebSocket features', data.features);
          break;
        case 'property_changed':
          this.handlePropertyChange(data);
          break;
        case 'property_freeze_changed':
          this.handleFreezeChange(data);
          break;
        case 'mapper_loaded':
          this.logDebug('üìã Mapper loaded via WebSocket');
          this.refreshCurrentMapper();
          this.refreshProperties();
          break;
      }
    }

    handlePropertyChange(data) {
      this.properties.set(data.property, {
        value: data.value,
        timestamp: new Date(data.timestamp),
        source: data.source || 'unknown'
      });

      this.changeHistory.unshift({
        property: data.property,
        value: data.value,
        oldValue: data.old_value,
        timestamp: new Date(data.timestamp),
        source: data.source
      });

      if (this.changeHistory.length > 50) {
        this.changeHistory.pop();
      }

      this.updatePropertyDisplay(data.property, data.value);
      this.updateChangeMonitoring();
    }

    handleFreezeChange(data) {
      const propertyElement = document.getElementById(`property-${data.property}`);
      if (propertyElement) {
        if (data.frozen) {
          propertyElement.classList.add('frozen');
        } else {
          propertyElement.classList.remove('frozen');
        }
      }
      this.showMessage(`Property ${data.property} ${data.frozen ? 'frozen' : 'unfrozen'}`, 'success');
    }

    async refreshMappers() {
      try {
        this.logDebug('üîÑ Fetching mappers list...');
        const response = await fetch(`${this.baseUrl}/api/mappers`);
        const data = await response.json();

        this.logDebug('üìã Mappers response', data);

        const mapperList = document.getElementById('mapperList');
        mapperList.innerHTML = '';

        if (data.mappers && data.mappers.length > 0) {
          data.mappers.forEach(mapper => {
            const li = document.createElement('li');
            li.className = 'mapper-item';
            li.innerHTML = `
                <div class="mapper-name">${mapper}</div>
                <div class="mapper-platform">Enhanced Mapper</div>
              `;
            li.addEventListener('click', () => {
              document.querySelectorAll('.mapper-item').forEach(item => {
                item.classList.remove('active');
              });
              li.classList.add('active');
              this.selectedMapperId = mapper;
              this.logDebug(`üìã Selected mapper: ${mapper}`);
            });
            mapperList.appendChild(li);
          });
          this.logDebug(`‚úÖ Loaded ${data.mappers.length} mappers`);
        } else {
          mapperList.innerHTML = '<li class="loading">No mappers found</li>';
          this.logDebug('‚ö†Ô∏è No mappers found');
        }
      } catch (error) {
        this.logDebug('‚ùå Failed to load mappers', error);
        this.showError('Failed to load mappers: ' + error.message);
      }
    }

    async loadSelectedMapper() {
      if (!this.selectedMapperId) {
        this.showError('Please select a mapper first');
        return;
      }

      try {
        this.logDebug(`üìã Loading mapper: ${this.selectedMapperId}`);
        const response = await fetch(`${this.baseUrl}/api/mappers/${this.selectedMapperId}/load`, {
          method: 'POST'
        });

        const data = await response.json();
        this.logDebug('üìã Load response', data);

        if (response.ok) {
          this.showSuccess(`Enhanced mapper ${this.selectedMapperId} loaded successfully`);
          this.logDebug(`‚úÖ Mapper ${this.selectedMapperId} loaded successfully`);
          setTimeout(() => {
            this.refreshCurrentMapper();
            this.refreshProperties();
          }, 1000);
        } else {
          this.logDebug(`‚ùå Failed to load mapper: ${data.message}`);
          this.showError(data.message || 'Failed to load mapper');
        }
      } catch (error) {
        this.logDebug('‚ùå Mapper load error', error);
        this.showError('Failed to load mapper: ' + error.message);
      }
    }

    async refreshCurrentMapper() {
      try {
        this.logDebug('üîÑ Fetching current mapper info...');
        const [mapperResponse, metaResponse] = await Promise.all([
          fetch(`${this.baseUrl}/api/mapper`),
          fetch(`${this.baseUrl}/api/mapper/meta`)
        ]);

        this.logDebug('üìä Mapper API responses', {
          mapperOk: mapperResponse.ok,
          metaOk: metaResponse.ok
        });

        if (mapperResponse.ok && metaResponse.ok) {
          this.currentMapper = await mapperResponse.json();
          const meta = await metaResponse.json();

          this.logDebug('üìä Current mapper data', this.currentMapper);
          this.logDebug('üìä Mapper meta data', meta);

          this.updateMapperDisplay(meta);
          this.updateStats(meta);
        } else {
          this.currentMapper = null;
          document.getElementById('mapperInfo').innerHTML = '<div class="loading">No mapper loaded</div>';
          this.logDebug('‚ö†Ô∏è No current mapper found');
        }
      } catch (error) {
        this.currentMapper = null;
        document.getElementById('mapperInfo').innerHTML = '<div class="loading">Failed to load mapper info</div>';
        this.logDebug('‚ùå Failed to fetch mapper info', error);
      }
    }

    updateMapperDisplay(meta) {
      const mapperInfo = document.getElementById('mapperInfo');
      if (meta) {
        mapperInfo.innerHTML = `
            <h3>${meta.name || 'Unknown Mapper'}</h3>
            <p><strong>Game:</strong> ${meta.game || 'Unknown'}</p>
            <p><strong>Version:</strong> ${meta.version || 'Unknown'}</p>
            <p><strong>Platform:</strong> ${meta.platform?.name || 'Unknown'}</p>
            <p><strong>Properties:</strong> ${meta.property_count || 0}</p>
            <p><strong>Groups:</strong> ${meta.group_count || 0}</p>
            <p><strong>Computed:</strong> ${meta.computed_count || 0}</p>
            <p><strong>Frozen:</strong> ${meta.frozen_count || 0}</p>
          `;
      } else {
        mapperInfo.innerHTML = '<div class="loading">No mapper loaded</div>';
      }
    }

    updateStats(meta) {
      if (meta) {
        document.getElementById('statProperties').textContent = meta.property_count || 0;
        document.getElementById('statFrozen').textContent = meta.frozen_count || 0;
        document.getElementById('statGroups').textContent = meta.group_count || 0;
        document.getElementById('statComputed').textContent = meta.computed_count || 0;
      }
    }

    async refreshProperties() {
      if (!this.currentMapper) {
        this.logDebug('‚ö†Ô∏è No current mapper, skipping property refresh');
        return;
      }

      try {
        this.logDebug('üîÑ Fetching properties and glossary...');
        const [propertiesResponse, glossaryResponse] = await Promise.all([
          fetch(`${this.baseUrl}/api/properties`),
          fetch(`${this.baseUrl}/api/mapper/glossary`)
        ]);

        this.logDebug('üìä Properties API responses', {
          propertiesOk: propertiesResponse.ok,
          glossaryOk: glossaryResponse.ok
        });

        if (propertiesResponse.ok && glossaryResponse.ok) {
          const propertiesData = await propertiesResponse.json();
          const glossaryData = await glossaryResponse.json();

          this.logDebug('üìä Properties data', propertiesData);
          this.logDebug('üìä Glossary data', glossaryData);

          this.renderPropertyGroups(propertiesData.properties, glossaryData.groups);
        } else {
          this.logDebug('‚ùå Failed to fetch properties or glossary');
          document.getElementById('propertyGroups').innerHTML = '<div class="empty-state">Failed to load properties</div>';
        }
      } catch (error) {
        this.logDebug('‚ùå Error refreshing properties', error);
        console.error('Failed to refresh properties:', error);
      }
    }

    renderPropertyGroups(properties, groups) {
      const container = document.getElementById('propertyGroups');
      container.innerHTML = '';

      this.logDebug(`üé® Rendering ${properties?.length || 0} properties in ${Object.keys(groups || {}).length} groups`);

      if (!properties || properties.length === 0) {
        container.innerHTML = '<div class="empty-state">No properties found</div>';
        return;
      }

      // Group properties by their groups
      const groupedProperties = new Map();
      const ungroupedProperties = [];

      // Initialize groups
      if (groups) {
        Object.entries(groups).forEach(([groupId, group]) => {
          groupedProperties.set(groupId, {
            info: group,
            properties: []
          });
        });
      }

      // Categorize properties
      properties.forEach(prop => {
        let assigned = false;
        if (groups) {
          Object.entries(groups).forEach(([groupId, group]) => {
            if (group.properties && group.properties.includes(prop.name)) {
              groupedProperties.get(groupId).properties.push(prop);
              assigned = true;
            }
          });
        }
        if (!assigned) {
          ungroupedProperties.push(prop);
        }
      });

      // Render groups
      groupedProperties.forEach((groupData, groupId) => {
        if (groupData.properties.length > 0) {
          container.appendChild(this.createPropertyGroupElement(groupId, groupData));
        }
      });

      // Render ungrouped properties
      if (ungroupedProperties.length > 0) {
        container.appendChild(this.createPropertyGroupElement('ungrouped', {
          info: { name: 'Other Properties', icon: 'üìã', description: 'Ungrouped properties' },
          properties: ungroupedProperties
        }));
      }

      this.logDebug(`‚úÖ Rendered property groups successfully`);
    }

    createPropertyGroupElement(groupId, groupData) {
      const group = document.createElement('div');
      group.className = 'property-group';
      group.innerHTML = `
          <div class="group-header" onclick="toggleGroup('${groupId}')">
            <span class="group-icon">${groupData.info.icon || 'üìã'}</span>
            <span class="group-title">${groupData.info.name}</span>
            <span class="group-toggle" id="toggle-${groupId}">‚ñº</span>
          </div>
          <div class="group-content" id="content-${groupId}">
            ${groupData.properties.map(prop => this.createPropertyElement(prop)).join('')}
          </div>
        `;
      return group;
    }

    createPropertyElement(prop) {
      const isComputed = prop.type === 'computed' || prop.name.includes('computed');
      const isFrozen = prop.frozen;
      const isReadOnly = prop.read_only;

      let classes = 'property-item';
      if (isComputed) classes += ' computed';
      if (isFrozen) classes += ' frozen';
      if (isReadOnly) classes += ' read-only';

      return `
          <div class="${classes}" id="property-${prop.name}">
            <div class="property-info">
              <div class="property-name">${prop.name}</div>
              <div class="property-description">${prop.description || 'No description'}</div>
              <div class="property-meta">
                ${prop.address || 'Computed'} ‚Ä¢ ${prop.type}
                ${isReadOnly ? '‚Ä¢ Read-only' : ''}
                ${isComputed ? '‚Ä¢ Computed' : ''}
              </div>
            </div>
            <div class="property-value" id="value-${prop.name}">
              ${this.formatValue(prop.value)}
            </div>
            <div class="property-actions">
              ${!isReadOnly && !isComputed ? `
                <button class="btn btn-small freeze-toggle ${isFrozen ? 'frozen' : ''}"
                        onclick="toggleFreeze('${prop.name}', ${!isFrozen})">
                  ${isFrozen ? 'üîì' : 'üßä'}
                </button>
              ` : ''}
            </div>
          </div>
        `;
    }

    updatePropertyDisplay(name, value) {
      const valueElement = document.getElementById(`value-${name}`);
      if (valueElement) {
        valueElement.textContent = this.formatValue(value);
        valueElement.style.animation = 'none';
        valueElement.offsetHeight; // Force reflow
        valueElement.style.animation = 'fadeIn 0.3s ease';
      }
    }

    updateChangeMonitoring() {
      const changesContainer = document.getElementById('propertyChanges');
      if (this.changeHistory.length === 0) {
        changesContainer.innerHTML = '<div class="empty-state">No property changes detected</div>';
        return;
      }

      changesContainer.innerHTML = this.changeHistory.slice(0, 20).map(change => `
          <div class="property-item" style="margin-bottom: 0.5rem;">
            <div class="property-info">
              <div class="property-name">${change.property}</div>
              <div class="property-meta">
                ${change.timestamp.toLocaleTimeString()} ‚Ä¢ ${change.source}
              </div>
            </div>
            <div class="property-value">
              ${this.formatValue(change.oldValue)} ‚Üí ${this.formatValue(change.value)}
            </div>
          </div>
        `).join('');
    }

    formatValue(value) {
      if (value === null || value === undefined) return '?';
      if (typeof value === 'number') {
        if (Number.isInteger(value)) return value.toString();
        return value.toFixed(2);
      }
      if (typeof value === 'boolean') return value ? 'true' : 'false';
      if (Array.isArray(value)) return `[${value.length} items]`;
      if (typeof value === 'object') return JSON.stringify(value);
      return String(value);
    }

    async toggleFreeze(propertyName, freeze) {
      try {
        this.logDebug(`üßä ${freeze ? 'Freezing' : 'Unfreezing'} property: ${propertyName}`);
        const response = await fetch(`${this.baseUrl}/api/properties/${propertyName}/freeze`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ freeze })
        });

        if (response.ok) {
          this.logDebug(`‚úÖ Property ${propertyName} ${freeze ? 'frozen' : 'unfrozen'}`);
        } else {
          const error = await response.json();
          this.logDebug(`‚ùå Failed to toggle freeze: ${error.message}`);
          this.showError(`Failed to ${freeze ? 'freeze' : 'unfreeze'} property: ${error.message}`);
        }
      } catch (error) {
        this.logDebug('‚ùå Freeze toggle error', error);
        this.showError(`Failed to toggle freeze: ${error.message}`);
      }
    }

    async testApiEndpoint(endpoint) {
      try {
        this.logDebug(`üß™ Testing API endpoint: ${endpoint}`);
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        const data = await response.json();
        this.logDebug(`‚úÖ API test result for ${endpoint}`, { status: response.status, data });
        this.showSuccess(`API test successful: ${endpoint}`);
      } catch (error) {
        this.logDebug(`‚ùå API test failed for ${endpoint}`, error);
        this.showError(`API test failed: ${endpoint}`);
      }
    }

    async testPropertyAccess() {
      if (!this.currentMapper) {
        this.showError('No mapper loaded');
        return;
      }

      this.logDebug('üß™ Testing individual property access...');

      // Test a few common properties
      const testProperties = ['playerName', 'teamCount', 'money', 'badges'];

      for (const propName of testProperties) {
        try {
          const response = await fetch(`${this.baseUrl}/api/properties/${propName}`);
          if (response.ok) {
            const data = await response.json();
            this.logDebug(`‚úÖ Property ${propName}`, data);
          } else {
            this.logDebug(`‚ùå Property ${propName} failed: ${response.status}`);
          }
        } catch (error) {
          this.logDebug(`‚ùå Property ${propName} error`, error);
        }
      }
    }

    showSuccess(message) {
      this.showMessage(message, 'success');
    }

    showError(message) {
      this.showMessage(message, 'error');
    }

    showMessage(message, type) {
      const messages = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;
      messageDiv.textContent = message;

      messages.appendChild(messageDiv);

      setTimeout(() => {
        messageDiv.remove();
      }, 5000);
    }
  }

  // Global functions
  let admin;

  function refreshMappers() {
    admin.refreshMappers();
  }

  function loadSelectedMapper() {
    admin.loadSelectedMapper();
  }

  function toggleGroup(groupId) {
    const content = document.getElementById(`content-${groupId}`);
    const toggle = document.getElementById(`toggle-${groupId}`);

    content.classList.toggle('collapsed');
    toggle.classList.toggle('collapsed');
  }

  function toggleFreeze(propertyName, freeze) {
    admin.toggleFreeze(propertyName, freeze);
  }

  function changeUpdateRate() {
    const select = document.getElementById('updateRateSelect');
    admin.updateRate = parseInt(select.value);
    document.getElementById('updateRate').textContent = `${Math.round(1000/admin.updateRate)} FPS`;
  }

  function toggleDebug() {
    admin.debugMode = !admin.debugMode;
    const debugPanel = document.getElementById('debugPanel');
    debugPanel.style.display = admin.debugMode ? 'block' : 'none';
  }

  function testApiEndpoint(endpoint) {
    admin.testApiEndpoint(endpoint);
  }

  function testPropertyAccess() {
    admin.testPropertyAccess();
  }

  // Initialize when page loads
  document.addEventListener('DOMContentLoaded', () => {
    admin = new EnhancedGameHookAdmin();
  });
</script>
</body>
</html>